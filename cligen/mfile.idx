nimTitle	mfile	cligen/mfile.html	module cligen/mfile		0
nim	PROT_RW	cligen/mfile.html#PROT_RW	let PROT_RW		19
nim	MFile	cligen/mfile.html#MFile	object MFile		22
nim	`[]`	cligen/mfile.html#[],MFile,HSlice[A,B]	proc `[]`[A, B](mf: MFile; s: HSlice[A, B]): MSlice		33
nim	mem	cligen/mfile.html#mem,MFile	proc mem(mf: MFile): pointer		35
nim	len	cligen/mfile.html#len,MFile	proc len(mf: MFile): int		36
nim	mem=	cligen/mfile.html#mem=,MFile,pointer	proc mem=(mf: var MFile; m: pointer)		37
nim	len=	cligen/mfile.html#len=,MFile,int	proc len=(mf: var MFile; n: int)		38
nim	fdClose	cligen/mfile.html#fdClose,MFile	proc fdClose(mf: MFile): int		48
nim	fdClose	cligen/mfile.html#fdClose,MFile_2	proc fdClose(mf: var MFile): int		51
nim	mopen	cligen/mfile.html#mopen,cint,cint,FileInfo	proc mopen(fd, fh: cint; fi: FileInfo; prot = PROT_READ; flags = MAP_SHARED;\n      a = 0.Off; b = Off(-1); allowRemap = false; noShrink = false; err = stderr): MFile		57
nim	mopen	cligen/mfile.html#mopen,cint,int	proc mopen(fh: cint; prot = PROT_READ; flags = MAP_SHARED; a = 0; b = Off(-1);\n      allowRemap = false; noShrink = false; err = stderr): MFile		94
nim	mopen	cligen/mfile.html#mopen,string,int,int,int	proc mopen(path: string; prot = PROT_READ; flags = MAP_SHARED; a = 0; b = -1;\n      allowRemap = false; noShrink = false; perMask = 0o000000000666;\n      err = stderr): MFile		108
nim	close	cligen/mfile.html#close,MFile	proc close(mf: MFile; err = stderr)		146
nim	close	cligen/mfile.html#close,MFile_2	proc close(mf: var MFile; err = stderr)		149
nim	resize	cligen/mfile.html#resize,MFile,int64	proc resize(mf: var MFile; newFileSize: int64; err = stderr): int		153
nim	add	cligen/mfile.html#add,MFile,char,T	proc add[T: SomeInteger](mf: var MFile; ch: char; off: var T)		189
nim	add	cligen/mfile.html#add,MFile,MSlice,T	proc add[T: SomeInteger](mf: var MFile; ms: MSlice; off: var T)		195
nim	inCore	cligen/mfile.html#inCore,MFile	proc inCore(mf: MFile): tuple[resident, total: int]		201
nim	`<`	cligen/mfile.html#<,MFile,MFile	proc `<`(a, b: MFile): bool		212
nim	`==`	cligen/mfile.html#==,MFile,MFile	proc `==`(a, b: MFile): bool		214
nim	`==`	cligen/mfile.html#==,MFile,pointer	proc `==`(a: MFile; p: pointer): bool		216
nim	toMSlice	cligen/mfile.html#toMSlice,MFile	proc toMSlice(mf: MFile): MSlice		218
nim	mSlices	cligen/mfile.html#mSlices.i,MFile,char,char	iterator mSlices(mf: MFile; sep = '\n'; eat = '\r'): MSlice		221
nim	lines	cligen/mfile.html#lines.i,MFile,string,char,char	iterator lines(mf: MFile; buf: var string; sep = '\n'; eat = '\r'): string		225
nim	lines	cligen/mfile.html#lines.i,MFile,char,char	iterator lines(mf: MFile; sep = '\n'; eat = '\r'): string		241
nim	rows	cligen/mfile.html#rows.i,MFile,Sep,seq[MSlice],int,char,char	iterator rows(mf: MFile; s: Sep; row: var seq[MSlice]; n = 0; sep = '\n'; eat = '\r'): seq[\n    MSlice]		249
nim	rows	cligen/mfile.html#rows.i,MFile,Sep,int,char,char	iterator rows(mf: MFile; s: Sep; n = 0; sep = '\n'; eat = '\r'): seq[MSlice]		257
nim	rows	cligen/mfile.html#rows.i,File,Sep,seq[string],int	iterator rows(f: File; s: Sep; row: var seq[string]; n = 0): seq[string]		262
nim	rows	cligen/mfile.html#rows.i,File,Sep,int	iterator rows(f: File; s: Sep; n = 0): seq[string]		268
nim	mSlices	cligen/mfile.html#mSlices.i,string,char,char,MFile	iterator mSlices(path: string; sep = '\n'; eat = '\r'; keep = false; err = stderr;\n        mf: var MFile = doNotUse): MSlice		274
nim	nSplit	cligen/mfile.html#nSplit,int,string,char	proc nSplit(n: int; path: string; sep = '\n'; prot = PROT_READ; flags = MAP_SHARED): tuple[\n    mf: MFile, parts: seq[MSlice]]		304
nimgrp	fdclose	cligen/mfile.html#fdClose-procs-all	proc		48
nimgrp	close	cligen/mfile.html#close-procs-all	proc		146
nimgrp	add	cligen/mfile.html#add-procs-all	proc		189
nimgrp	mopen	cligen/mfile.html#mopen-procs-all	proc		57
nimgrp	==	cligen/mfile.html#==-procs-all	proc		214
nimgrp	rows	cligen/mfile.html#rows-iterators-all	iterator		249
nimgrp	lines	cligen/mfile.html#lines-iterators-all	iterator		225
nimgrp	mslices	cligen/mfile.html#mSlices-iterators-all	iterator		221
